"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2955],{836:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>x,frontMatter:()=>l,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"js/how-js-works/closure","title":"Closure","description":"A function along with its lexical scope (i.e. the variables from the outer function) is called a closure.","source":"@site/docs/js/how-js-works/closure.mdx","sourceDirName":"js/how-js-works","slug":"/js/how-js-works/closure","permalink":"/docs/js/how-js-works/closure","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/js/how-js-works/closure.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"javascriptSidebar","previous":{"title":"Scope and Scope Chain","permalink":"/docs/js/how-js-works/scope"},"next":{"title":"Event loop, Callback queue and microtask queue","permalink":"/docs/js/how-js-works/event-loop"}}');var i=s(4848),r=s(8453);const t=s.p+"assets/images/scopes_and_outerEnv-3b634542b981d1664ec9e9e6d3265ff1.jpg",c=s.p+"assets/images/closure_notes1-7c805671798cb440573151eba80a1678.jpg",l={sidebar_position:4},a="Closure",d={},h=[{value:"How Closures are implemented",id:"how-closures-are-implemented",level:3},{value:"Uses of closure:",id:"uses-of-closure",level:3},{value:"Disadvantages of closure:",id:"disadvantages-of-closure",level:3},{value:"Doubts/To cover",id:"doubtsto-cover",level:3},{value:"References",id:"references",level:3},{value:"Notes",id:"notes",level:3}];function u(e){const n={admonition:"admonition",code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"closure",children:"Closure"})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.p,{children:"A function along with its lexical scope (i.e. the variables from the outer function) is called a closure."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'function outer() {\n  let outerVar = "I am from outer";\n\n  function inner() {\n    console.log(outerVar); // Accessing outer variable creates a closure scope\n  }\n\n  return inner;\n}\nconst innerFunc = outer();\ninnerFunc();\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Unlike other scopes, ",(0,i.jsx)(n.strong,{children:"Closure scope"})," do not create a special or new type of Lexical Environment, instead:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The inner function gets its own Lexical Environment when it is executed."}),"\n",(0,i.jsx)(n.li,{children:"But it retains a reference to the Lexical Environment of the outer function, even after the outer function has returned."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'So the closure scope refers to a preserved outer Lexical Environment \u2014 not a separate "closure Lexical Environment"'}),"\n",(0,i.jsxs)(n.admonition,{type:"warning",children:[(0,i.jsxs)(n.p,{children:["Closures store the ",(0,i.jsx)(n.strong,{children:"reference"})," to the outer Lexical Environment, not the ",(0,i.jsx)(n.strong,{children:"values"})," of the variables. So if the outer variable changes, the inner function will see the updated value."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"for (var i = 0; i < 3; i++) {\n  setTimeout(function () {\n    console.log(i); // 3, 3, 3\n  }, 1000);\n}\n"})}),(0,i.jsxs)(n.p,{children:["In the above example, the ",(0,i.jsx)(n.code,{children:"setTimeout"})," function creates a closure that retains a reference to the outer Lexical Environment. By the time the timeout executes, the loop has completed and ",(0,i.jsx)(n.code,{children:"i"})," is 3."]}),(0,i.jsx)(n.p,{children:"To fix this, we can use an IIFE to create a new scope for each iteration:"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"for (var i = 0; i < 3; i++) {\n  (function (i) {\n    setTimeout(function () {\n      console.log(i); // 0, 1, 2\n    }, 1000);\n  })(i);\n}\n"})})]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"how-closures-are-implemented",children:"How Closures are implemented"}),"\n",(0,i.jsxs)(n.p,{children:["Javascript engines use a special internal property called ",(0,i.jsx)(n.code,{children:"[[Scopes]]"})," to keep track of the outer Lexical Environment."]}),"\n",(0,i.jsx)("img",{src:t,alt:"Scopes and OuterEnv",height:600}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"uses-of-closure",children:"Uses of closure:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Data hiding"}),"\n",(0,i.jsx)(n.li,{children:"Module design pattern"}),"\n",(0,i.jsx)(n.li,{children:"Currying"}),"\n",(0,i.jsx)(n.li,{children:"Functions like Once"}),"\n",(0,i.jsx)(n.li,{children:"Memoization"}),"\n",(0,i.jsx)(n.li,{children:"Maintaining State in async world"}),"\n",(0,i.jsx)(n.li,{children:"setTimeouts"}),"\n",(0,i.jsx)(n.li,{children:"iterators"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"disadvantages-of-closure",children:"Disadvantages of closure:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Memory leaks"}),"\n",(0,i.jsx)(n.li,{children:"Event listeners Garbage collection"}),"\n",(0,i.jsx)(n.li,{children:"Performance issues"}),"\n",(0,i.jsx)(n.li,{children:"Debugging issues"}),"\n",(0,i.jsx)(n.li,{children:"Complexity"}),"\n",(0,i.jsx)(n.li,{children:"Unintentional variable retention"}),"\n",(0,i.jsx)(n.li,{children:"Garbage collection issues"}),"\n",(0,i.jsx)(n.li,{children:"Overhead of maintaining scope chain"}),"\n",(0,i.jsx)(n.li,{children:"Unintentional retention of outer variables"}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"doubtsto-cover",children:"Doubts/To cover"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"How IIFE creates a new closure scope?"}),"\n",(0,i.jsxs)(n.li,{children:["Relation between ",(0,i.jsx)(n.code,{children:"[[Scopes]]"}),"/",(0,i.jsx)(n.code,{children:"[[Environment]]"})," & ",(0,i.jsx)(n.code,{children:"[[OuterEnv]]"})," of lexical environment"]}),"\n",(0,i.jsxs)(n.li,{children:["How closure is implemented using ",(0,i.jsx)(n.code,{children:"[[Scopes]]"}),"/",(0,i.jsx)(n.code,{children:"[[Environment]]"}),". Give both examples of what is saved in ",(0,i.jsx)(n.code,{children:"[[Scopes]]"})," when there's a outer variable access vs when there's no outer variable access."]}),"\n",(0,i.jsxs)(n.li,{children:["Compile time vs runtime what happens for ",(0,i.jsx)(n.code,{children:"[[Scopes]]"}),"/",(0,i.jsx)(n.code,{children:"[[Environment]]"}),"/",(0,i.jsx)(n.code,{children:"[[OuterEnv]]"}),". Inner and outer example with JIT compilation."]}),"\n",(0,i.jsxs)(n.li,{children:["Why ",(0,i.jsx)(n.code,{children:"[[Scopes]]"})," has all the outer scopes present? Shouldn't just outer scope be enough? Also does it only contain outer scope which are closures? Verify this."]}),"\n",(0,i.jsxs)(n.li,{children:["What is the significance of order/index of elements in ",(0,i.jsx)(n.code,{children:"[[Scopes]]"}),"? Which scope is present at first and last and why?"]}),"\n",(0,i.jsx)(n.li,{children:"Where in memory is closure stored? How it affects garbage collection and slows down the performance?"}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"references",children:"References"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h3,{id:"notes",children:"Notes"}),"\n",(0,i.jsx)("img",{src:c,alt:"Closure Notes",height:600})]})}function x(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>c});var o=s(6540);const i={},r=o.createContext(i);function t(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);