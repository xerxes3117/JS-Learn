"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6933],{8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var o=n(6540);const r={},s=o.createContext(r);function i(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:t},e.children)}},9021:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"js/how-js-works/prototypal-inheritance","title":"Prototypal Inheritance","description":"What is prototypal inheritance?","source":"@site/docs/js/how-js-works/prototypal-inheritance.mdx","sourceDirName":"js/how-js-works","slug":"/js/how-js-works/prototypal-inheritance","permalink":"/docs/js/how-js-works/prototypal-inheritance","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/js/how-js-works/prototypal-inheritance.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"javascriptSidebar","previous":{"title":"Event loop, Callback queue and microtask queue","permalink":"/docs/js/how-js-works/event-loop"},"next":{"title":"Fundamentals","permalink":"/docs/category/fundamentals"}}');var r=n(4848),s=n(8453);const i={sidebar_position:4},c="Prototypal Inheritance",a={},d=[{value:"What is prototypal inheritance?",id:"what-is-prototypal-inheritance",level:3},{value:"<code>prototype</code>",id:"prototype",level:4},{value:"<code>__proto__</code>",id:"__proto__",level:4},{value:"Doubts/To cover",id:"doubtsto-cover",level:3},{value:"References",id:"references",level:3},{value:"Notes",id:"notes",level:3}];function h(e){const t={a:"a",code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"prototypal-inheritance",children:"Prototypal Inheritance"})}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(t.h3,{id:"what-is-prototypal-inheritance",children:"What is prototypal inheritance?"}),"\n",(0,r.jsx)(t.h4,{id:"prototype",children:(0,r.jsx)(t.code,{children:"prototype"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Every function in JavaScript has a property called ",(0,r.jsx)(t.code,{children:"prototype"}),". When you create a new object using that function as a constructor (i.e. using ",(0,r.jsx)(t.code,{children:"new"})," keyword), the new object inherits properties and methods from the constructor's prototype."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"prototype"})," is responsible for creating the prototype chain by defining ",(0,r.jsx)(t.code,{children:"__proto__"})," for the object created by the constructor function."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["You don't have to necessarily use the ",(0,r.jsx)(t.code,{children:"new"})," keywords in some cases. Here is table of equivalent ways to create an object, arrays, strings, etc.:"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Constructor"}),(0,r.jsx)(t.th,{children:"Literal"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Object"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"new Object()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"{}"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Array"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"new Array()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"[]"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"new String()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"''"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Number"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"new Number()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"0"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Boolean"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"new Boolean()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"false"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Function"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"new Function()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"function () {}"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Date"}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"new Date()"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"new Date()"})})]})]})]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"prototype"})," property is an object itself, and it can have its own properties and methods. When you create a new object using a constructor function, the new object has access to the properties and methods defined on the constructor's prototype."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"ES6 class syntax is a syntactical sugar over the existing prototype-based inheritance. It allows you to create classes and define methods on the class's prototype"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'// Using ES6 class syntax\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\nconst person1 = new Person("Alice");\nperson1.greet();\n\n// Using constructor function\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.greet = function () {\n  console.log(`Hello, my name is ${this.name}`);\n};\nconst person1 = new Person("Alice");\nperson1.greet();\n'})}),"\n",(0,r.jsx)(t.h4,{id:"__proto__",children:(0,r.jsx)(t.code,{children:"__proto__"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"__proto__"})," property is a reference to the prototype of an object. When accessing a property on an object, it is this ",(0,r.jsx)(t.code,{children:"__proto__"})," (and not the ",(0,r.jsx)(t.code,{children:"prototype"})," property of the constructor function) that is used to look up the prototype chain."]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(t.h3,{id:"doubtsto-cover",children:"Doubts/To cover"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Check in ",(0,r.jsx)(t.a,{href:"https://javascript.info/prototypes",children:"https://javascript.info/prototypes"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"highlighted texts"}),"\n",(0,r.jsx)(t.li,{children:"summary of each article"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["Difference between ",(0,r.jsx)(t.code,{children:"[[Prototype]]"})," and ",(0,r.jsx)(t.code,{children:"__proto__"}),"?"]}),"\n",(0,r.jsx)(t.li,{children:"Prototype can only be an object or null. Why not a function? What happens when you set a function as prototype? What happens when you set a primitive type as prototype? Does it throw an error or does it get converted to an object? Or is it totally ignored?"}),"\n",(0,r.jsx)(t.li,{children:"What exactly inheriting a property means? How to check if a property is inherited or not?"}),"\n",(0,r.jsx)(t.li,{children:"Enumerable, writable, configurable properties of an object. How to check if a property is enumerable or not? How to make a property non-enumerable?"}),"\n",(0,r.jsxs)(t.li,{children:["What all happens when you create an object using ",(0,r.jsx)(t.code,{children:"new"})," keyword? ",(0,r.jsx)(t.code,{children:"Object.create"})," vs ",(0,r.jsx)(t.code,{children:"new"})," keyword"]}),"\n",(0,r.jsxs)(t.li,{children:["What ",(0,r.jsx)(t.code,{children:"delete obj.prop"})," does? Does it delete the property from the prototype chain or just the object?"]}),"\n",(0,r.jsxs)(t.li,{children:["How using ",(0,r.jsx)(t.code,{children:"prototype"})," instead of defining methods inside the ",(0,r.jsx)(t.code,{children:"constructor"})," function is more memory efficient? Take example of both native and user defined prototypes"]}),"\n",(0,r.jsxs)(t.li,{children:["Even though they are not objects, Primitive types are also able to access methods like ",(0,r.jsx)(t.code,{children:"toUpperCase"}),", ",(0,r.jsx)(t.code,{children:"toString"}),", etc. How is that possible? What happens when you call a method on a primitive type? Does it create a wrapper object? Is this wrapper object temporary or permanent?"]}),"\n",(0,r.jsx)(t.li,{children:"Why modifying a native prototype is considered a bad idea except in case of polyfills. polyfills vs monkey patching."}),"\n",(0,r.jsx)(t.li,{children:"Unlike languages like C++, javascript only allows single inheritance. How to achieve multiple inheritance in javascript? What are the drawbacks of multiple inheritance? Why is it not supported in javascript?"}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsxs)(t.strong,{children:["What are accessor properties? What is advantage of using them? What is the difference between accessor properties and data properties? Why ",(0,r.jsx)(t.code,{children:"__proto__"})," is an accessor property?"]})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsxs)(t.strong,{children:["What is use of getter/setter inherited from ",(0,r.jsx)(t.code,{children:"Object.prototype"}),"? When are these called? How to use them?"]})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsxs)(t.strong,{children:["What is the use of ",(0,r.jsx)(t.code,{children:"Object.getOwnPropertyDescriptor"}),"?"]})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsxs)(t.strong,{children:['What does this mean: "',(0,r.jsx)(t.strong,{children:"proto"}),' is not a property of the object itself, but an accessor property (getter/setter) inherited from Object.prototype." (see ',(0,r.jsx)(t.a,{href:"https://javascript.info/prototype-methods#very-plain",children:"https://javascript.info/prototype-methods#very-plain"}),")"]})}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Object.create(null)"})," How this object will be different from a normal object? What is the use case of this object? How to create an object with null prototype? What are the drawbacks of this object? (see ",(0,r.jsx)(t.a,{href:"https://javascript.info/prototype-methods#very-plain",children:"https://javascript.info/prototype-methods#very-plain"}),")"]}),"\n"]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(t.h3,{id:"references",children:"References"}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(t.h3,{id:"notes",children:"Notes"})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);